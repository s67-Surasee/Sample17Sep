int[][] grid = new int[3][4];
boolean[][] hidden = new boolean[3][4]; 
boolean waitingForMatch = false; 
int firstRow = -1, firstCol = -1; 
int secondRow = -1, secondCol = -1;
boolean[][] revealed = new boolean[3][4];
int revealTime = 1000; 
int revealStartTime = 0; 

void setup() {
    size(500, 500);
    strokeWeight(12);
    background(255);

    populateGrid();

    for (int i = 0; i < hidden.length; i++) {
        for (int j = 0; j < hidden[0].length; j++) {
            hidden[i][j] = true;
            revealed[i][j] = false; 
        }
    }
}

void populateGrid() {
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[i].length; j++) {
            grid[i][j] = int(random(1, 7)); 
        }
    }
}

void draw() {
    background(255);

    int rows = grid.length;
    int cols = grid[0].length;

    int w = width / cols; 
    int h = height / rows; 

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            draw_grid(j * w, i * h, w, h);

            if (!hidden[i][j] || revealed[i][j] || (i == firstRow && j == firstCol) || (i == secondRow && j == secondCol)) {
                draw_lines(10 + j * w, 10 + i * h, grid[i][j]);
            }
        }
    }

    if (waitingForMatch && millis() - revealStartTime > revealTime) {
        if (grid[firstRow][firstCol] != grid[secondRow][secondCol]) {
            hidden[firstRow][firstCol] = true;
            hidden[secondRow][secondCol] = true;
        } else {
            revealed[firstRow][firstCol] = true;
            revealed[secondRow][secondCol] = true;
        }
        
        firstRow = -1;
        firstCol = -1;
        secondRow = -1;
        secondCol = -1;
        waitingForMatch = false; 
    }
}

void draw_grid(int x, int y, int w, int h) {
    noFill();
    stroke(0);
    strokeWeight(2);
    rect(x, y, w, h);
}

void draw_lines(int x, int y, int n) {
    strokeWeight(12);
    for (int i = 0; i < n; i++) {
        line(x + i * 20, y, x + i * 20, y + 40);
    }
}

void mousePressed() {
    if (waitingForMatch) return;

    int cols = grid[0].length;
    int rows = grid.length;

    int w = width / cols;
    int h = height / rows;

    int clickedCol = mouseX / w;
    int clickedRow = mouseY / h;

    if (clickedCol >= 0 && clickedCol < cols && clickedRow >= 0 && clickedRow < rows) {
        if (hidden[clickedRow][clickedCol]) {
            hidden[clickedRow][clickedCol] = false; 

            if (firstRow == -1 && firstCol == -1) {
                firstRow = clickedRow;
                firstCol = clickedCol; 
            }
            else if (secondRow == -1 && secondCol == -1) {
                secondRow = clickedRow;
                secondCol = clickedCol; 

                waitingForMatch = true; 
                revealStartTime = millis(); 
            }
        }
    }
}
